
# test_views.py - Generated by CodiumAI


"""
Code Analysis:
- The main goal of the function is to authenticate a token and return the corresponding user.
- The function takes a token as input.
- It decodes the token using the SECRET_KEY specified in the settings file and the HS256 algorithm.
- It retrieves the user_id from the decoded token and uses it to retrieve the corresponding user from the database.
- If the token has expired, it raises an AuthenticationFailed exception with the message 'Token has expired'.
- If the token is invalid, it raises an AuthenticationFailed exception with the message 'Token is invalid'.
- If the user does not exist, it raises an AuthenticationFailed exception with the message 'User not found'.
- If the token is valid and the user exists, it returns the user object.
"""
from datetime import datetime, timedelta

import jwt
import pytest
from rest_framework.exceptions import AuthenticationFailed

from ess_api import settings
from ess_api_backend.models import User
from ess_api_backend.views import authenticate_token

"""
Test Plan:
- test_valid_token(): tests that a valid token is provided and user exists in the database. Tags: [happy path]
- test_mock_user_model(): tests that the function works as expected when the User model is mocked. Tags: [happy path]
- test_mock_jwt_library(): tests that the function works as expected when the jwt library is mocked. Tags: [happy path]
- test_expired_token(): tests that the function raises an AuthenticationFailed exception with the message 'Token has expired' when the token has expired. Tags: [edge case]
- test_invalid_token(): tests that the function raises an AuthenticationFailed exception with the message 'Token is invalid' when the token is invalid. Tags: [edge case]
- test_unexpected_exception(): tests that the function handles unexpected exceptions gracefully. Tags: [general behavior]
- test_user_not_found(): tests that the function raises an AuthenticationFailed exception with the message 'User not found' when the user does not exist in the database. Tags: [edge case]
- test_missing_user_id(): tests that the function raises an exception when the token payload is missing the 'user_id' key. Tags: [edge case]
- test_mock_user_model_and_jwt_library(): tests that the function works as expected when both the User model and jwt library are mocked. Tags: [happy path]
- test_performance(): tests that the function performs well under heavy load. Tags: [general behavior]
"""


class TestAuthenticateToken:
    def test_valid_token(self, mocker):
        # happy path test
        user = User.objects.create(email='test@example.com', password='password')
        token = jwt.encode({'user_id': user.id}, settings.SECRET_KEY, algorithm='HS256')
        mocker.patch('jwt.decode', return_value={'user_id': user.id})
        assert authenticate_token(token) == user

    def test_mock_user_model(self, mocker):
        # happy path test with mocked User model
        mocker.patch('authenticate_token.User.objects.get', side_effect=User.DoesNotExist)
        with pytest.raises(AuthenticationFailed):
            authenticate_token('mocked_token')

    def test_mock_jwt_library(self, mocker):
        # happy path test with mocked jwt library
        mocker.patch('jwt.decode', side_effect=jwt.DecodeError)
        with pytest.raises(AuthenticationFailed):
            authenticate_token('mocked_token')

    def test_expired_token(self, mocker):
        # edge case test with expired token
        user = User.objects.create(email='test@example.com', password='password')
        token = jwt.encode({'user_id': user.id, 'exp': datetime.utcnow() - timedelta(seconds=1)}, settings.SECRET_KEY,
                           algorithm='HS256')
        mocker.patch('jwt.decode', return_value={'user_id': user.id, 'exp': datetime.utcnow() - timedelta(seconds=1)})
        with pytest.raises(AuthenticationFailed) as exc:
            authenticate_token(token)
        assert str(exc.value) == 'Token has expired'

    def test_invalid_token(self, mocker):
        # edge case test with invalid token
        mocker.patch('jwt.decode', side_effect=jwt.DecodeError)
        with pytest.raises(AuthenticationFailed) as exc:
            authenticate_token('invalid_token')
        assert str(exc.value) == 'Token is invalid'

    def test_unexpected_exception(self, mocker):
        # general behavior test with unexpected exception
        mocker.patch('jwt.decode', side_effect=Exception)
        with pytest.raises(Exception):
            authenticate_token('mocked_token')